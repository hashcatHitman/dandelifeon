// SPDX-FileCopyrightText: Copyright Â© 2025 hashcatHitman
//
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! A library for searching for solutions to the Dandelifeon using the bees
//! algorithm.

use core::cmp::Ordering;
use core::fmt::{Display, Formatter, Result};

use rand::Rng;
use rand::seq::SliceRandom as _;

use crate::bees::{Colony, Scout};
use crate::simulation::PetriDish;

pub mod bees;
pub mod simulation;

/// A measurement of fitness for a simulated Dandelifeon game.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Score {
    /// The mana generated by the game.
    mana: u16,
    /// The initial cell cost of the game.
    cell_cost: u16,
    /// The initial "blocker" cost of the game.
    block_cost: u16,
}

impl Display for Score {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(
            f,
            "({} mana, cost {} cells and {} blocks)",
            self.mana, self.cell_cost, self.block_cost
        )
    }
}

impl PartialOrd for Score {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Score {
    fn cmp(&self, other: &Self) -> Ordering {
        if let ord @ (Ordering::Less | Ordering::Greater) =
            self.mana.cmp(&other.mana)
        {
            return ord.reverse();
        }
        if let ord @ (Ordering::Less | Ordering::Greater) =
            self.cell_cost.cmp(&other.cell_cost)
        {
            return ord;
        }
        self.block_cost.cmp(&other.block_cost)
    }
}

/// A [`Colony`] for running the bees algorithm to find solutions to the
/// Dandelifeon.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Hive {
    /// The iteration count.
    iters: usize,
}

impl Hive {
    /// Creates a new [`Hive`].
    pub const fn new() -> Self {
        Self { iters: 0 }
    }
}

impl Default for Hive {
    fn default() -> Self {
        Self::new()
    }
}

impl Colony<60> for Hive {
    type Flower = PetriDish;
    type Nectar = Score;

    const ELITE_SITES: usize = 5;
    const BEST_SITES: usize = 55;
    const ELITE_RECRUITS: usize = 10;
    const BEST_RECRUITS: usize = 5;
    const FLOWER_PATCH_SIZE: usize = 25 * 25;
    const STAGNATION_LIMIT: usize = 21;

    fn evaluate(solution: &Self::Flower) -> Self::Nectar {
        let mut game: PetriDish = *solution;
        let mana: u16 = game.play();
        let (cell_cost, block_cost) = solution.count_living_and_blocked();

        Score {
            mana,
            cell_cost,
            block_cost,
        }
    }

    fn explore<R: Rng>(
        origin: &Self::Flower,
        current_best: &Scout<60, Self>,
        radius: usize,
        rng: &mut R,
    ) -> Self::Flower {
        if radius == (25 * 25) {
            let new: Self::Flower = rng.random();
            return new;
        }
        let mut base: Self::Flower = if radius <= Self::MINIMUM_RADIUS {
            current_best.solution()
        } else {
            *origin
        };
        let mut coords: [(u8, u8); 624] = Self::Flower::NONCENTER_COORDS;

        coords.shuffle(rng);

        for (x, y) in coords.into_iter().take(radius) {
            let value: u8 = rng.random_range(0..3);
            base.write(x, y, value);
        }
        base
    }

    fn stopping_condition(&mut self) -> bool {
        // Just keep going.
        false
    }
}
